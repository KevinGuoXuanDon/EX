package leetcode.DP;

/**
 * 有人说这题像是麻将传播到了美国233333,确实像
 *
 * 给你一个下标从 0 开始的整数数组 nums ，你必须将数组划分为一个或多个 连续 子数组。
 *
 * 如果获得的这些子数组中每个都能满足下述条件 之一 ，则可以称其为数组的一种 有效 划分：
 *
 * 子数组 恰 由 2 个相等元素组成，例如，子数组 [2,2] 。
 * 子数组 恰 由 3 个相等元素组成，例如，子数组 [4,4,4] 。
 * 子数组 恰 由 3 个连续递增元素组成，并且相邻元素之间的差值为 1 。例如，子数组 [3,4,5] ，但是子数组 [1,3,5] 不符合要求。
 * 如果数组 至少 存在一种有效划分，返回 true ，否则，返回 false 。
 *
 * 
 *
 * 示例 1：
 *
 * 输入：nums = [4,4,4,5,6]
 * 输出：true
 * 解释：数组可以划分成子数组 [4,4] 和 [4,5,6] 。
 * 这是一种有效划分，所以返回 true 。
 */
public class CheckValidPartition {
    /**
     * 动态规划：
     * 可以算是一个很经典的动态规划题。
     * 因为转移方程式题目已经告诉了，只要想到了动态规划就可以解。
     *
     * 贪心思路：
     * 一开始想着贪心做,但是边界处理会比较麻烦，因为要思考是否需要借元素
     * 比如 1 1 1 2 3 4 5 6
     * 已经知道重复元素只要>=2就组成有效划分，并且>2的话就可以进行借位
     * 可以拆成 1 1 / 1 2 3/ 4 5 6
     * 那么对于 1 1 1 2 3 4 5 6 7
     * 拆成    1 1 1/ 2 3 4 / 5 6 7
     * 此时就不能借位，否则7无法处理  1 1/ 1 2 3/ 4 5 6/ 7
     * 所以需要判断后面的元素是否连续且个数为3的倍数，如果是则不能借
     * 如果不是，则需要借并且最多补充1位
     *
     */
    public boolean validPartition(int[] nums) {
        int n = nums.length;
        boolean[] dp = new boolean[n];
        dp[0] = false;
        if(nums[0] == nums[1]){
            dp[1] = true;
        }
        // 边界值处理
        if(n<=2){
            return dp[n-1];
        }
        dp[2] = (nums[0]==nums[1] && nums[1]==nums[2]) || (nums[0]+1==nums[1] && nums[1]+1==nums[2]);
        for(int i=3;i<n; i++){
            // 当前位和上一位是否相同， 并且0到i-2的数字能够形成有效组合
            boolean b1 = dp[i-2] &&  nums[i-1] == nums[i];
            // 连续三位相同
            boolean b2 = dp[i-3] && ((nums[i-1] == nums[i]) && (nums[i-2] == nums[i-1]));
            // 连续三位连续
            boolean b3 = dp[i-3] && ((nums[i] == nums[i-1]+1) && (nums[i-1]== nums[i-2]+1));
            dp[i] = b1 || b2 || b3;
        }
        return dp[n-1];
    }

}
