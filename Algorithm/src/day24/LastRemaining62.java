package day24;

/**
 * 0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。
 *
 * 例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。
 *
 *
 * 输入: n = 5, m = 3
 * 输出: 3
 */

//4ms 99.97%
public class LastRemaining62 {
    //有可能 m > n ，因此删除的数字为 (m - 1)%n ，删除后的数字环从下个数字（m%n）开始
    //f(n) = ( f(n-1) + m%n )%n
    // 0 1 2 3 4 ，n=5,m=3，第一轮后f(5)-> 0 1 3 4，并且从3开始计数，也就是3 4 0 1,且此时长度为4
    // 对于还没有做操作的f(4)来说，0 1 2 3 只需要对每个数加m余n，就能变成f(5): 0 1 2 3-> 3 4 0 1， 然后就可以接着做删除第三个数字
    public int lastRemaining(int n, int m){
        int dp = 0;//当 n = 1，f(n)=0
        for (int i = 2; i < n; i++) {
            dp= (dp+m)%i;//左边的dp为f(n+1),右边的为fn. 动态转移方程f(n+1)= (f(n)+m)%(n+1);
        }
        return dp;
    }
}
